import{_ as s,o as a,c as n,Q as o}from"./chunks/framework.3d945e71.js";const m=JSON.parse('{"title":"D2C设计方案调研：FigmaToCode 设计稿转代码 布局方案剖析！","description":"","frontmatter":{},"headers":[],"relativePath":"frontend-advanced/设计稿转代码/D2C设计方案调研：FigmaToCode 设计稿转代码 布局方案剖析！.md","filePath":"frontend-advanced/设计稿转代码/D2C设计方案调研：FigmaToCode 设计稿转代码 布局方案剖析！.md","lastUpdated":1699412326000}'),p={name:"frontend-advanced/设计稿转代码/D2C设计方案调研：FigmaToCode 设计稿转代码 布局方案剖析！.md"},l=o(`<h1 id="d2c设计方案调研-figmatocode-设计稿转代码-布局方案剖析" tabindex="-1">D2C设计方案调研：FigmaToCode 设计稿转代码 布局方案剖析！ <a class="header-anchor" href="#d2c设计方案调研-figmatocode-设计稿转代码-布局方案剖析" aria-label="Permalink to &quot;D2C设计方案调研：FigmaToCode 设计稿转代码 布局方案剖析！&quot;">​</a></h1><p>大家好，很久没发文章了，这次我又来卷D2C这一块了~~ 由于最近组内决定去做D2C, 所以或多或少得研究一下业内的一些实现方案，然而真实情况是，我们也是摸着石头过河，前期要花费很多时间去调研，研究实现方案。其中就包括 <a href="https://github.com/bernaferrari/FigmaToCode" target="_blank" rel="noreferrer">FigmaToCode</a> 这个开源项目。</p><p>本文不会贴很多代码，不利于理解。FigmaToCode 的实现其实并不复杂，但是用它生成的结果来看，还是偏差比较多的，这也是我们可以进一步优化的地方。</p><h2 id="figmatocode演示" tabindex="-1">FigmaToCode演示 <a class="header-anchor" href="#figmatocode演示" aria-label="Permalink to &quot;FigmaToCode演示&quot;">​</a></h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba98b3b678a64e5392d63d468c7c6f9d~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>FigmaToCode支持将设计稿转成 <code>HTML</code> 和 <code>TailWind</code>等</p><h2 id="figma的自动布局" tabindex="-1">Figma的自动布局 <a class="header-anchor" href="#figma的自动布局" aria-label="Permalink to &quot;Figma的自动布局&quot;">​</a></h2><p>其实Figma自带 flex布局的一些特性， 甚至是grid布局，如果你开发过Figma设计稿，可以看到这里：</p><table><thead><tr><th>flex布局</th><th>grid布局</th></tr></thead><tbody><tr><td><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98e7af21310748318a337e508f366f68~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></td><td><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5392acec2064077befe78c60e13a381~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></td></tr></tbody></table><p>可以看到左边flex布局，可以实现各种对齐方式，这就意味着，如果设计人员可以规范设计，能使用自动布局就尽量用，对于我们来说就可以减少很多无用的判断和处理。</p><p>目前<code>FigmaToCode</code>只处理flex布局，如果设计人员没有使用<code>Auto Layout</code>这个模式，会自己计算内部节点的位置，来断定使用了什么布局，并且强制将该节点是<code>Auto Layout</code>。</p><h2 id="figma中的节点类型" tabindex="-1">Figma中的节点类型 <a class="header-anchor" href="#figma中的节点类型" aria-label="Permalink to &quot;Figma中的节点类型&quot;">​</a></h2><p>在Figma中存在很多种类型的节点，就像下面这样，当然这里并没有展示出全部的节点类型</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b6a8ff79e0b4d0285ef05b2b2890757~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>列举下常用的节点类型：</p><ul><li><strong>RECTANGLE 矩形</strong></li><li><strong>ELLIPSE 椭圆</strong></li><li><strong>LINE 线形</strong></li><li><strong>FRAME 框架：</strong> 相当于一个容器，子节点的x, y 位置都是相对于 Frame 来定位, 有布局功能</li><li><strong>INSTANCE组件实例：</strong> Figma中也存在组件的概念，相当于new Component()</li><li><strong>COMPONENT 组件</strong></li><li><strong>GROUP 组</strong>： 本身没有自己的大小和位置, 你可以理解为它内部的子节点是捆绑在这个组的。也可能子节点在Group的外面。</li><li><strong>TEXT 文本</strong></li><li><strong>VECTOR 矢量图</strong>：可以用于创建各种形状，例如线条、多边形、圆形、椭圆形等等。可以理解为前端里的 SVG, 放大不会失真。</li><li><strong>SECTION 容器</strong>：和Frame类似，但是没有布局功能（Auto Layout）</li></ul><h2 id="figma节点属性的作用" tabindex="-1">Figma节点属性的作用 <a class="header-anchor" href="#figma节点属性的作用" aria-label="Permalink to &quot;Figma节点属性的作用&quot;">​</a></h2><p>Figma 节点的属性可以分为以下几类：</p><ol><li>基本属性：节点的 ID、名称、类型、可见性等等。</li><li>几何属性：节点的位置、大小、旋转、缩放等等。</li><li>样式属性：节点的填充、边框、阴影、透明度等等。</li><li>文本属性：文本节点的字体、字号、颜色、对齐方式等等。</li><li>布局属性：容器节点的布局方式、间距、对齐方式等等。</li><li>组件属性：组件节点的主组件、实例、覆盖等等。</li></ol><p>但是当你打印出figma node属性，可以发现属性太多了。。</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cae0709d435b47b7af3a85137457c79e~tplv-k3u1fbpfcp-watermark.image?" alt="" width="20%"><p>我们要处理每个属性吗？其实大可不必，真正需要的属性其实只有一部分，我们要做的就是要清洗数据，并构建新的节点树。</p><p>以下是 Figma 节点的常见属性及其作用：</p><ol><li><code>id</code>：节点的唯一标识符。</li><li><code>name</code>：节点的名称。</li><li><code>type</code>：节点的类型，例如 <code>RECTANGLE</code>、<code>TEXT</code>、<code>GROUP</code> 等等。</li><li><code>visible</code>：节点的可见性，控制节点是否在设计中可见。</li><li><code>locked</code>：节点的锁定状态，控制节点是否可以编辑。</li><li><code>opacity</code>：节点的不透明度，控制节点的透明度。</li><li><code>blendMode</code>：节点的混合模式，控制节点与其下方节点的混合方式。</li><li><code>constraints</code>：节点的约束，控制节点在其父容器中的位置和大小。</li><li><code>layoutAlign</code>：容器节点的对齐方式，控制容器中的子节点如何对齐。</li><li><code>layoutMode</code>：容器节点的布局方式，控制容器中的子节点如何排列。</li><li><code>padding</code>：容器节点的内边距，控制容器中的子节点与容器边缘的距离。</li><li><code>fills</code>：节点的填充，控制节点的填充颜色和样式。</li><li><code>strokes</code>：节点的边框，控制节点的边框颜色和样式。</li><li><code>strokeWeight</code>：节点的边框宽度，控制节点的边框粗细。</li><li><code>cornerRadius</code>：节点的圆角半径，控制节点的圆角大小。</li><li><code>characters</code>：文本节点的文本内容。</li><li><code>fontName</code>：文本节点的字体名称。</li><li><code>fontSize</code>：文本节点的字体大小。</li><li><code>textAlignHorizontal</code>：文本节点的水平对齐方式。</li><li><code>textAlignVertical</code>：文本节点的垂直对齐方式。</li><li><code>textCase</code>：文本节点的大小写转换方式。</li><li><code>textDecoration</code>：文本节点的文本修饰方式。</li><li><code>textStyleId</code>：文本节点的文本样式 ID。</li><li><code>componentId</code>：组件节点的主组件 ID。</li><li><code>instanceId</code>：组件实例节点的实例 ID。</li><li><code>overrides</code>：组件实例节点的覆盖，控制组件实例与主组件的差异。</li><li>...</li></ol><p>当然这并不是全部，如果要处理的情况太多，我们就需要借助其他属性进一步分析。</p><h2 id="布局树生成" tabindex="-1">布局树生成 <a class="header-anchor" href="#布局树生成" aria-label="Permalink to &quot;布局树生成&quot;">​</a></h2><p>上面说了那么多，<code>FigmaToCode</code>是如何处理没有<code>AutoLayout</code>的节点呢？ 我们先从一个例子开始：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0231ef7a54e34680a46e3ebe3c3d9cf9~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>在Figma中，可以认为整个是一个树的结构，FigmaToCode首先会清洗其中的数据，组成新的Node节点。在上面的例子中，我们可以得到如下的树结构：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/11fe0181efca46f3b8bacc36f84d1a0e~tplv-k3u1fbpfcp-watermark.image?" alt="未命名文件 (8).png"></p><p>首先声明一点：<strong>在没有使用自动布局的情况下，才会计算布局</strong></p><p>下面我们来看看<code>FigmaToCode</code>是如何实现自动布局的</p><p>1.在遇到<code>Frame</code>节点时：</p><ul><li>创建一个 Frame 节点，并拷贝 <code>Frame</code>上的属性，包含 name、id、布局位置、大小等信息</li></ul><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/acd8c2e33801486cb03ba2cc559c7f1e~tplv-k3u1fbpfcp-watermark.image?" alt="未命名文件 (14).png"></p><p><strong>我们可以把创建的新节点叫做 <code>alternate</code>节点</strong></p><p>如果大家有看过<code>React源码</code>，相信大家对这个名字不会陌生。</p><ol start="2"><li>继续递归子节点<code>Frame</code> 和 <code>Rectangle</code>、<code>Text</code>等，在这个过程中，依然会创建新节点，并拷贝其中必要的属性。</li></ol><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e30997742fef4fd4aaaac44cc340487a~tplv-k3u1fbpfcp-watermark.image?" alt="未命名文件 (13).png"></p><ol start="3"><li>回溯时开始自动布局</li></ol><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9281bc593deb4ebca57f90260398d551~tplv-k3u1fbpfcp-watermark.image?" alt="未命名文件 (12).png"></p><p>我们知道递归是深度遍历，在递归完<code>蓝色框</code>部分时，会回溯到<code>Frame</code>这个节点，此时对于<code>Frame</code>来说，我们需要计算出，<code>Frame</code>内部节点的具体排布。</p><p>然后为<code>Frame</code>的<code>Alternate</code>节点，也就是<code>rectangle</code>节点，设置<code>layoutMode</code> 布局方式，以及其他布局信息。</p><h2 id="布局分析" tabindex="-1">布局分析 <a class="header-anchor" href="#布局分析" aria-label="Permalink to &quot;布局分析&quot;">​</a></h2><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01ed7f7e06ef4635b01f9c8a2173e2aa~tplv-k3u1fbpfcp-watermark.image?" alt="未命名文件 (11).png"></p><p>在这一步中，我们将分析<code>Text</code>节点和<code>Rectangle</code>的位置，来确定布局方式。</p><h3 id="_1-碰撞检测" tabindex="-1">1. 碰撞检测 <a class="header-anchor" href="#_1-碰撞检测" aria-label="Permalink to &quot;1. 碰撞检测&quot;">​</a></h3><p>不管什么需求，必定存在元素重叠的情况，这种情况如何处理呢？</p><p>以下图为例，一个矩形中包含 <code>一个文本节点</code> 和 <code>一个椭圆节点</code></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1b4d0b3a0d546aa9066158ecc1dde2f~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>首先建立每个元素和重叠节点 之间映射管理，例如</p><pre><code>{
  n3: [n1, n2] 
}
</code></pre><p>如果 n3 包含 (n1 和 n2) , 然后再做进一步转换</p><ul><li><code>n3</code>是<code>rectangle</code>节点，需要将其强制转为<code>Frame</code>节点</li><li>修改n1 和 n2的 x, y， 因为之前是相对于上一层的<code>frame</code>， 要修改为相对于刚才转换的<code>frame</code>中。同时parent同样指向刚才转换的<code>frame</code></li></ul><h3 id="_2-计算布局方向" tabindex="-1">2. 计算布局方向 <a class="header-anchor" href="#_2-计算布局方向" aria-label="Permalink to &quot;2. 计算布局方向&quot;">​</a></h3><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c64955d5dfa4f0e95e9e6f723c79b82~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>怎么知道子元素是 <code>水平</code> 还是 <code>垂直</code> 方向的排布呢？</p><ul><li><p>从小到大排序 <code>y1 .. y2</code> ，计算 <code>y1 .. y2</code> 的间距, 同理，如果有 <code>y1 .. y4</code>, 就从小到大排序，并计算<code>y1..y2</code> <code>y2..y3</code> <code>y3..y4</code>的间隔，最后算出间隔平均值</p></li><li><p>从小到大排序 <code>x1 .. x2</code> ，计算 <code>x1 .. x2</code> 的间距, 同理，如果有 <code>x1 .. x4</code>, 就从小到大排序，并计算<code>x1..x2</code> <code>x2..x3</code> <code>x3..x4</code>的间隔，最后算出间隔平均值</p></li><li><p>如果子元素在垂直方向上没有对齐，则检查它们是否在水平方向上对齐。如果子元素在垂直和水平方向上都没有对齐，则返回 &quot;NONE&quot;。最后返回对齐方向 和 平均间隔。代码逻辑如下：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">intervalY.</span><span style="color:#B392F0;">every</span><span style="color:#E1E4E8;">((</span><span style="color:#FFAB70;">d</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> d </span><span style="color:#F97583;">&gt;=</span><span style="color:#E1E4E8;"> threshold)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">intervalX.</span><span style="color:#B392F0;">every</span><span style="color:#E1E4E8;">((</span><span style="color:#FFAB70;">d</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> d </span><span style="color:#F97583;">&gt;=</span><span style="color:#E1E4E8;"> threshold)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (avgY </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> threshold) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (avgX </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> threshold) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> [</span><span style="color:#9ECBFF;">&quot;NONE&quot;</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">];</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> [</span><span style="color:#9ECBFF;">&quot;HORIZONTAL&quot;</span><span style="color:#E1E4E8;">, avgX];</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> [</span><span style="color:#9ECBFF;">&quot;VERTICAL&quot;</span><span style="color:#E1E4E8;">, avgY];</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> [</span><span style="color:#9ECBFF;">&quot;HORIZONTAL&quot;</span><span style="color:#E1E4E8;">, avgX];</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">intervalY.</span><span style="color:#6F42C1;">every</span><span style="color:#24292E;">((</span><span style="color:#E36209;">d</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> d </span><span style="color:#D73A49;">&gt;=</span><span style="color:#24292E;"> threshold)) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">intervalX.</span><span style="color:#6F42C1;">every</span><span style="color:#24292E;">((</span><span style="color:#E36209;">d</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> d </span><span style="color:#D73A49;">&gt;=</span><span style="color:#24292E;"> threshold)) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (avgY </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> threshold) {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (avgX </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> threshold) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> [</span><span style="color:#032F62;">&quot;NONE&quot;</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">];</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> [</span><span style="color:#032F62;">&quot;HORIZONTAL&quot;</span><span style="color:#24292E;">, avgX];</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> [</span><span style="color:#032F62;">&quot;VERTICAL&quot;</span><span style="color:#24292E;">, avgY];</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> [</span><span style="color:#032F62;">&quot;HORIZONTAL&quot;</span><span style="color:#24292E;">, avgX];</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div></li><li><p>如果是水平对齐，则使用子节点的 x 值重新排序</p></li><li><p>如果是垂直对齐，则使用子节点的 y 值重新排序</p></li></ul><h3 id="_3-计算容器padding" tabindex="-1">3. 计算容器padding <a class="header-anchor" href="#_3-计算容器padding" aria-label="Permalink to &quot;3. 计算容器padding&quot;">​</a></h3><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0392d627827c41a3a4a8ed9e102cf0dc~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>这一步开始计算容器的padding值</p><ul><li>容器width - 最右侧元素x === paddingRight</li><li>容器width - 最左侧元素x === paddingLeft</li><li>容器height - 最下面元素 y === paddingBottom</li><li>容器height - 最上面元素 y === paddingTop</li></ul><h3 id="_4-单独计算子节点的-align-items-布局对齐" tabindex="-1">4. 单独计算子节点的 align-items 布局对齐 <a class="header-anchor" href="#_4-单独计算子节点的-align-items-布局对齐" aria-label="Permalink to &quot;4. 单独计算子节点的 align-items 布局对齐&quot;">​</a></h3><p>学过flex布局的同学，应该知道有<code>align-items: stretch</code> 这个值，如果元素的宽度或高度与容器一致，我们需要单独设置。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac3381918c4f46ce8f006900212866aa~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>判断也很简单，元素的宽度或高度与容器一致，单独设置子元素的<code>layoutAlign</code>为<code>STRETCH</code></p><h3 id="_5-确定子节点-主轴-或-交叉轴" tabindex="-1">5. 确定子节点 主轴 或 交叉轴 <a class="header-anchor" href="#_5-确定子节点-主轴-或-交叉轴" aria-label="Permalink to &quot;5. 确定子节点 主轴 或 交叉轴&quot;">​</a></h3><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7ea640fb52d4a74b7192c56a3857edd~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>前面我们已经计算出了元素整体的方向，<code>水平</code> 或 <code>垂直</code>。</p><p>但是并没有精确到每个元素，我们必须明确标注元素的<code>direction</code>、<code>justify-content</code>, <code>align-items</code>。</p><p>确定它们在轴线上是 <code>start</code>, <code>end</code>, <code>center</code>三个哪种情况</p><p>在下面的函数中，接收一个子节点 和 容器父节点。我们只需要根据节点的<code>x</code>, <code>y</code>, 就可以知道在<code>主轴</code> 和 <code>交叉轴</code>中，处于什么位置。</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">primaryAxisDirection</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#FFAB70;">node</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">AltSceneNode</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#FFAB70;">parentNode</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">AltFrameNode</span></span>
<span class="line"><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> { </span><span style="color:#FFAB70;">primary</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;MIN&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;CENTER&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;MAX&quot;</span><span style="color:#E1E4E8;">; </span><span style="color:#FFAB70;">counter</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;MIN&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;CENTER&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;MAX&quot;</span><span style="color:#E1E4E8;"> } </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">nodeCenteredPosX</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> node.x </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> node.width </span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">parentCenteredPosX</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> parentNode.width </span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">centerXPosition</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> nodeCenteredPosX </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> parentCenteredPosX;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">nodeCenteredPosY</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> node.y </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> node.height </span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">parentCenteredPosY</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> parentNode.height </span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">centerYPosition</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> nodeCenteredPosY </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> parentCenteredPosY;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (parentNode.layoutMode </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;VERTICAL&quot;</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">      primary: </span><span style="color:#B392F0;">getPaddingDirection</span><span style="color:#E1E4E8;">(centerYPosition),</span></span>
<span class="line"><span style="color:#E1E4E8;">      counter: </span><span style="color:#B392F0;">getPaddingDirection</span><span style="color:#E1E4E8;">(centerXPosition),</span></span>
<span class="line"><span style="color:#E1E4E8;">    };</span></span>
<span class="line"><span style="color:#E1E4E8;">  } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">      primary: </span><span style="color:#B392F0;">getPaddingDirection</span><span style="color:#E1E4E8;">(centerXPosition),</span></span>
<span class="line"><span style="color:#E1E4E8;">      counter: </span><span style="color:#B392F0;">getPaddingDirection</span><span style="color:#E1E4E8;">(centerYPosition),</span></span>
<span class="line"><span style="color:#E1E4E8;">    };</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">};</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">primaryAxisDirection</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#E36209;">node</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">AltSceneNode</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#E36209;">parentNode</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">AltFrameNode</span></span>
<span class="line"><span style="color:#24292E;">)</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> { </span><span style="color:#E36209;">primary</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;MIN&quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">|</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;CENTER&quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">|</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;MAX&quot;</span><span style="color:#24292E;">; </span><span style="color:#E36209;">counter</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;MIN&quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">|</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;CENTER&quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">|</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;MAX&quot;</span><span style="color:#24292E;"> } </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">nodeCenteredPosX</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> node.x </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> node.width </span><span style="color:#D73A49;">/</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">parentCenteredPosX</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> parentNode.width </span><span style="color:#D73A49;">/</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">centerXPosition</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> nodeCenteredPosX </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> parentCenteredPosX;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">nodeCenteredPosY</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> node.y </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> node.height </span><span style="color:#D73A49;">/</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">parentCenteredPosY</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> parentNode.height </span><span style="color:#D73A49;">/</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">centerYPosition</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> nodeCenteredPosY </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> parentCenteredPosY;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (parentNode.layoutMode </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;VERTICAL&quot;</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">      primary: </span><span style="color:#6F42C1;">getPaddingDirection</span><span style="color:#24292E;">(centerYPosition),</span></span>
<span class="line"><span style="color:#24292E;">      counter: </span><span style="color:#6F42C1;">getPaddingDirection</span><span style="color:#24292E;">(centerXPosition),</span></span>
<span class="line"><span style="color:#24292E;">    };</span></span>
<span class="line"><span style="color:#24292E;">  } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">      primary: </span><span style="color:#6F42C1;">getPaddingDirection</span><span style="color:#24292E;">(centerXPosition),</span></span>
<span class="line"><span style="color:#24292E;">      counter: </span><span style="color:#6F42C1;">getPaddingDirection</span><span style="color:#24292E;">(centerYPosition),</span></span>
<span class="line"><span style="color:#24292E;">    };</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">};</span></span></code></pre></div><p>但是这样还不足以确定<code>justify-content</code>和<code>align-items</code>的值什么，我们还要知道每个子节点，在主轴/ 交叉轴 出现最多次的对齐方式。例如，有四个节点，在主轴上，有一个是<code>center</code>, 而另外三个是<code>start</code>, 统计处出现次数最多的，基本可以认定，在主轴方向上 <code>justify-content: flex-start</code></p><h2 id="结语" tabindex="-1">结语 <a class="header-anchor" href="#结语" aria-label="Permalink to &quot;结语&quot;">​</a></h2><p>本文分析的比较简单，因为太难表达了。。涉及的细节很多，有不少没有列举出来，并且主要针对自动布局做了分析。</p><p>整体来看，实现并不复杂，搞懂了这些还不够，后续再结合业内其他方案，做进一步调研。</p>`,77),e=[l];function t(c,r,i,E,y,d){return a(),n("div",null,e)}const u=s(p,[["render",t]]);export{m as __pageData,u as default};
