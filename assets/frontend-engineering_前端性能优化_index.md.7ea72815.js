import{_ as e,o,c as l,Q as i}from"./chunks/framework.3d945e71.js";const m=JSON.parse('{"title":"前端性能优化","description":"","frontmatter":{"index":false},"headers":[],"relativePath":"frontend-engineering/前端性能优化/index.md","filePath":"frontend-engineering/前端性能优化/index.md","lastUpdated":1697507502000}'),a={name:"frontend-engineering/前端性能优化/index.md"},d=i('<h1 id="前端性能优化" tabindex="-1">前端性能优化 <a class="header-anchor" href="#前端性能优化" aria-label="Permalink to &quot;前端性能优化&quot;">​</a></h1><h2 id="_1-构建速度优化" tabindex="-1">1. 构建速度优化 <a class="header-anchor" href="#_1-构建速度优化" aria-label="Permalink to &quot;1. 构建速度优化&quot;">​</a></h2><ul><li>使用 webpack5 持久化缓存，能明显提高构件速度</li><li>使用 <code>lazyCompilation</code> 可以懒编译，能明显提高开发构建速度</li><li>约束loader的<code>include</code>和<code>exclude</code>，可以跳过某些编译。</li><li>使用<code>module.noParse</code> 可以跳过对某些文件的编译，因为有些三方库是已经编译过的，并且没有导出，如jquery</li><li>优化<code>source-map</code>的配置，使用<code>eval-cheap-source-map</code>可以提高构建速度, eval可缓存。</li><li>借助<code>swc</code>, <code>esbuild</code>等高性能编译器，优化构建速度, 例如terser插件可以指定使用<code>swc</code>或<code>esbuild</code>对代码进行压缩</li><li>采用并行压缩，例如：<code>thread-loader</code>、<code>terser</code>插件自带的<code>parallel</code>参数。</li></ul><h2 id="_2-构建体积优化" tabindex="-1">2. 构建体积优化 <a class="header-anchor" href="#_2-构建体积优化" aria-label="Permalink to &quot;2. 构建体积优化&quot;">​</a></h2><ul><li><p>尽量使用 <code>export {}</code> 导出代码， 若<code>export default {}</code>, 会被全部导出, 失去tree-shaking效果</p></li><li><p>不要使用babel将esm转为cjs， 若代码是<code>commonjs</code>代码，将失去tree-shaking优化，需要设置<code>baberc</code>配置中的<code>modules: false</code></p></li><li><p><code>babel</code>搭配<code>transform-runtime</code>插件，可以将<code>babel runtime</code>的代码模块化引入，减少了代码冗余， 同时设置<code>preset-env</code>的<code>useBuiltIns: &#39;usage&#39;</code></p></li><li><p><code>babel</code> 通过<code>targets</code>配置可以有效减少<code>core-js</code>的体积</p></li><li><p><code>lib库</code> 酌情使用 <code>sideEffects</code>，通过设置<code>package.json</code>中的<code>sideEffects</code>字段，可以告诉webpack哪些是纯的（无副作用），进而对<code>lib库</code> tree-shaking</p></li><li><p>使用 <code>unplugin-vue-components</code> 或 <code>babel-plugin-import</code> 按需引入组件</p></li><li><p>可以使用 <code>/*#__PURE__ */</code> 标记哪些函数没有副作用，进而tree-shaking</p></li><li><p>合理配置<code>split-chunk-plugin</code>，例如其中的<code>maxInitialRequests</code>和<code>maxAsyncRequests</code>属性，用于控制异步模块和入口模块的拆分粒度。能有效减少重复打包的模块。如果是Vite或Rollup， 可以借助 <code>manualChunks</code> 对代码进行拆包</p></li><li><p>三方模块，尽量提取为CDN, 可以有效减小包体积大小。</p></li><li><p>gzip压缩</p></li><li><p>路由懒加载，可以有效减小入口文件的大小，减少白屏率。</p></li><li><p>使用插件对图片进行压缩</p></li></ul><h2 id="_3-网络优化" tabindex="-1">3. 网络优化 <a class="header-anchor" href="#_3-网络优化" aria-label="Permalink to &quot;3. 网络优化&quot;">​</a></h2><ul><li>使用http2的多路复用，可以突破HTTP 1.x 的请求并发限制，头部压缩等功能。</li><li>采用CDN</li><li>prefetch：优先级较低，可以在浏览器空闲时加载一些资源，例如提前加载下一个页面的资源，增加后续的打开速度</li><li>preload：优先级高，提前加载必要的资源</li><li>modulepreload: 原生esm可以进行预加载</li><li>DNS 预解析, 通过 dns-prefetch 技术将这一过程提前，降低 DNS 解析的延迟时间</li></ul><h2 id="_4-运行时优化" tabindex="-1">4. 运行时优化 <a class="header-anchor" href="#_4-运行时优化" aria-label="Permalink to &quot;4. 运行时优化&quot;">​</a></h2><ul><li>虚拟列表</li><li>防抖、节流</li><li>图片懒加载，并且使用CDN</li><li>requestAnimationFrame 优化动画或一些阻塞浏览器渲染的操作</li><li>动画操作使用<code>transform</code>，减少触发重排与重绘</li><li>使用骨架屏优化用户体验</li><li>v-memo优化列表渲染性能</li></ul><h2 id="_5-其他优化" tabindex="-1">5. 其他优化 <a class="header-anchor" href="#_5-其他优化" aria-label="Permalink to &quot;5. 其他优化&quot;">​</a></h2><ul><li>服务端渲染</li></ul><h1 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h1><p>总结了一些工作中对项目优化的手段，欢迎补充~</p>',13),c=[d];function t(r,n,s,p,u,h){return o(),l("div",null,c)}const b=e(a,[["render",t]]);export{m as __pageData,b as default};
