import{_ as e,o as c,c as d,Q as o}from"./chunks/framework.3d945e71.js";const s=JSON.parse('{"title":"3.说一下 computed 如何实现的","description":"","frontmatter":{"order":3},"headers":[],"relativePath":"frontend-advanced/vue/Vue2/3.说一下computed如何实现的.md","filePath":"frontend-advanced/vue/Vue2/3.说一下computed如何实现的.md","lastUpdated":1729873804000}'),t={name:"frontend-advanced/vue/Vue2/3.说一下computed如何实现的.md"},a=o('<h1 id="_3-说一下-computed-如何实现的" tabindex="-1">3.说一下 computed 如何实现的 <a class="header-anchor" href="#_3-说一下-computed-如何实现的" aria-label="Permalink to &quot;3.说一下 computed 如何实现的&quot;">​</a></h1><h2 id="核心答案" tabindex="-1">核心答案 <a class="header-anchor" href="#核心答案" aria-label="Permalink to &quot;核心答案&quot;">​</a></h2><p>计算属性会在它使用到的响应式变量变化时，重新求值。在计算属性初始化时，会为其创建<code>computed watcher</code>。 它重新求值的条件是<code>dirty</code>为<code>true</code>, 核心点在于，响应式变量收集的依赖，它最终会收集到<code>computed watcher</code>和<code>渲染watcher</code>， 当修改某个响应式变量后，<code>computed watcher</code>会把<code>dirty</code>设置为<code>true</code>, <code>渲染watcher</code>会触发计算属性的 getter, 重新求值。</p><h2 id="补充回答" tabindex="-1">补充回答 <a class="header-anchor" href="#补充回答" aria-label="Permalink to &quot;补充回答&quot;">​</a></h2><ol><li><p>为每个 computed 创建 watcher，并且 lazy 为 true, watcher 创建时不会进行求值</p></li><li><p>模板渲染时，触发 computed 的 getter, <code>watcher.dirty</code>为<code>true</code>进行求值</p></li><li><p>求值过程中，使用到了响应式变量，触发响应式变量 getter，收集依赖，此时依赖栈包含<code>computed watcher</code>和<code>渲染watcher</code></p></li><li><p>响应式 dep 收集的依赖是<code>computed watcher</code>, 注意~不是<code>渲染watcher</code>，此时依赖栈包含<code>渲染watcher</code></p></li><li><p>计算属性的 deps 数组收集 响应式变量的 Dep 对象</p></li><li><p><code>computed watcher</code>通知所有的 deps，去收集依赖, 此时收集的都是<code>渲染watcher</code></p></li><li><p>这时候所有 computed 用到的响应式变量,其中收集的依赖都包含, <code>computed watcher</code>和<code>渲染watcher</code></p></li></ol>',5),r=[a];function p(i,u,l,_,h,n){return c(),d("div",null,r)}const w=e(t,[["render",p]]);export{s as __pageData,w as default};
