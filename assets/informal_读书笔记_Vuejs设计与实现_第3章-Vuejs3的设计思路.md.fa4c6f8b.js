import{_ as s,o as a,c as n,Q as l}from"./chunks/framework.3d945e71.js";const u=JSON.parse('{"title":"Vue.js 设计与实现阅读笔记（三）第3章-Vue.js 3 的设计思路","description":"","frontmatter":{},"headers":[],"relativePath":"informal/读书笔记/Vuejs设计与实现/第3章-Vuejs3的设计思路.md","filePath":"informal/读书笔记/Vuejs设计与实现/第3章-Vuejs3的设计思路.md","lastUpdated":1696903260000}'),p={name:"informal/读书笔记/Vuejs设计与实现/第3章-Vuejs3的设计思路.md"},o=l(`<h1 id="vue-js-设计与实现阅读笔记-三-第3章-vue-js-3-的设计思路" tabindex="-1">Vue.js 设计与实现阅读笔记（三）第3章-Vue.js 3 的设计思路 <a class="header-anchor" href="#vue-js-设计与实现阅读笔记-三-第3章-vue-js-3-的设计思路" aria-label="Permalink to &quot;Vue.js 设计与实现阅读笔记（三）第3章-Vue.js 3 的设计思路&quot;">​</a></h1><h1 id="_3-1-声明式的描述ui" tabindex="-1">3.1 声明式的描述UI <a class="header-anchor" href="#_3-1-声明式的描述ui" aria-label="Permalink to &quot;3.1 声明式的描述UI&quot;">​</a></h1><p>Vue3是一个声明式的框架，对于一个DOM树来说，它用声明式，可以这么写：</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">div</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">@click</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;handler&quot;</span><span style="color:#E1E4E8;">&gt;&lt;</span><span style="color:#85E89D;">span</span><span style="color:#E1E4E8;">&gt;&lt;/</span><span style="color:#85E89D;">span</span><span style="color:#E1E4E8;">&gt;&lt;/</span><span style="color:#85E89D;">div</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">div</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">@click</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;handler&quot;</span><span style="color:#24292E;">&gt;&lt;</span><span style="color:#22863A;">span</span><span style="color:#24292E;">&gt;&lt;/</span><span style="color:#22863A;">span</span><span style="color:#24292E;">&gt;&lt;/</span><span style="color:#22863A;">div</span><span style="color:#24292E;">&gt;</span></span></code></pre></div><p>不管是dom元素的创建，还是dom上的事件绑定，都不需要我们手动用命令式来写。</p><p>除了上面这种模板写法，Vue3还支持用Javascript对象来描述：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">div</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  tag: </span><span style="color:#9ECBFF;">&#39;div&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  props: {</span></span>
<span class="line"><span style="color:#E1E4E8;">    onClick: handler</span></span>
<span class="line"><span style="color:#E1E4E8;">  },</span></span>
<span class="line"><span style="color:#E1E4E8;">  children: [</span></span>
<span class="line"><span style="color:#E1E4E8;">     {tag: </span><span style="color:#9ECBFF;">&#39;span&#39;</span><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#E1E4E8;">  ]</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">div</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  tag: </span><span style="color:#032F62;">&#39;div&#39;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  props: {</span></span>
<span class="line"><span style="color:#24292E;">    onClick: handler</span></span>
<span class="line"><span style="color:#24292E;">  },</span></span>
<span class="line"><span style="color:#24292E;">  children: [</span></span>
<span class="line"><span style="color:#24292E;">     {tag: </span><span style="color:#032F62;">&#39;span&#39;</span><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#24292E;">  ]</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>那对象的写法有什么好处呢？可以想象如下场景：</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">h1</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">v-if</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;tag === &#39;h1&#39;&quot;</span><span style="color:#E1E4E8;">&gt;&lt;/</span><span style="color:#85E89D;">h1</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">h2</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">v-else-if</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;tag === &#39;h2&#39;&quot;</span><span style="color:#E1E4E8;">&gt;&lt;/</span><span style="color:#85E89D;">h2</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">h3</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">v-else-if</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;tag === &#39;h3&#39;&quot;</span><span style="color:#E1E4E8;">&gt;&lt;/</span><span style="color:#85E89D;">h3</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">h1</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">v-if</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;tag === &#39;h1&#39;&quot;</span><span style="color:#24292E;">&gt;&lt;/</span><span style="color:#22863A;">h1</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">h2</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">v-else-if</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;tag === &#39;h2&#39;&quot;</span><span style="color:#24292E;">&gt;&lt;/</span><span style="color:#22863A;">h2</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">h3</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">v-else-if</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;tag === &#39;h3&#39;&quot;</span><span style="color:#24292E;">&gt;&lt;/</span><span style="color:#22863A;">h3</span><span style="color:#24292E;">&gt;</span></span></code></pre></div><p>如果用对象的写法就非常简单了：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">div</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  tag: tag,</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">div</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  tag: tag,</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h2 id="_3-2-初识渲染器" tabindex="-1">3.2 初识渲染器 <a class="header-anchor" href="#_3-2-初识渲染器" aria-label="Permalink to &quot;3.2 初识渲染器&quot;">​</a></h2><p>渲染器的作用就是把虚拟 DOM 渲染为真实 DOM， 如下图</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/121cb135c32240bea6a0c0acbe871f67~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">renderer</span><span style="color:#E1E4E8;">(vnode, document.body)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">renderer</span><span style="color:#24292E;">(vnode, document.body)</span></span></code></pre></div><p>渲染器 renderer 的实现思路，总体来说 分为三步。</p><ul><li><p>创建元素：把 vnode.tag 作为标签名称来创建 DOM 元素。</p></li><li><p>为元素添加属性和事件：遍历 vnode.props 对象，如果 key 以 on 字符开头，说明它是一个事件，把字符 on 截取掉后再调用 toLowerCase 函数将事件名称小写化，最终得到合法的事件名 称，例如 onClick 会变成 click，最后调用 addEventListener 绑定事件处理函数。</p></li><li><p>处理 children：如果 children 是一个数组，就递归地调用 renderer 继续渲染，注意，此时我们要把刚刚创建的元素作为 挂载点（父节点）；如果 children 是字符串，则使用 createTextNode 函数创建一个文本节点，并将其添加到新创建 的元素内。</p></li></ul><p><strong>简单来讲：在上面的代码中，renderer 会递归遍历Vnode, 根据vnode创建对应的dom节点，最后append到<code>document.body</code>上。对于渲染器来说，它需要精确地找到 vnode 对象的变更点并且只 更新变更的内容。就上例来说，渲染器应该只更新元素的文本内容， 而不需要再走一遍完整的创建元素的流程。</strong></p><h2 id="_3-3-组件的本质" tabindex="-1">3.3 组件的本质 <a class="header-anchor" href="#_3-3-组件的本质" aria-label="Permalink to &quot;3.3 组件的本质&quot;">​</a></h2><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">MyComponent</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#B392F0;">render</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        tag: </span><span style="color:#9ECBFF;">&#39;div&#39;</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">   }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">MyComponent</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#6F42C1;">render</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        tag: </span><span style="color:#032F62;">&#39;div&#39;</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">   }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>可以看到，组件的返回值也是虚拟 DOM，它代表组件要渲染的内 容。搞清楚了组件的本质，我们就可以定义用虚拟 DOM 来描述组件。很简单，我们可以让虚拟 DOM 对象中的 tag 属性来存储组件：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">vnode</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">   tag: MyComponent</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">vnode</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">   tag: MyComponent</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>渲染器在递归渲染的过程中，如果遇到组件vnode, 就需要调用它内部的render, 获取<code>subtree</code>，并进一步递归其中的子vnode。</p><h2 id="_3-4-模板的工作原理" tabindex="-1">3.4 模板的工作原理 <a class="header-anchor" href="#_3-4-模板的工作原理" aria-label="Permalink to &quot;3.4 模板的工作原理&quot;">​</a></h2><p>简单来讲，就是需要编译器编译成渲染函数，后续章节会讲~</p><h2 id="_3-5-vue-js-是各个模块组成的有机整体" tabindex="-1">3.5 Vue.js 是各个模块组成的有机整体 <a class="header-anchor" href="#_3-5-vue-js-是各个模块组成的有机整体" aria-label="Permalink to &quot;3.5 Vue.js 是各个模块组成的有机整体&quot;">​</a></h2><p>如前所述，<code>组件的实现依赖于渲染器</code>，<code>模板的编译依赖于编译器</code>，并且编译后生成的代码是根据渲染器和虚拟 DOM 的设计决定的， 因此 Vue.js 的各个模块之间是互相关联、互相制约的，共同构成一个 有机整体。因此，我们在学习 Vue.js 原理的时候，应该把各个模块结 合到一起去看，才能明白到底是怎么回事。</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">div</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">id</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;foo&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">:class</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;cls&quot;</span><span style="color:#E1E4E8;">&gt;&lt;/</span><span style="color:#85E89D;">div</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">div</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">id</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;foo&quot;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">:class</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;cls&quot;</span><span style="color:#24292E;">&gt;&lt;/</span><span style="color:#22863A;">div</span><span style="color:#24292E;">&gt;</span></span></code></pre></div><p>根据上文的介绍，我们知道编译器会把这段代码编译成渲染函数：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">render</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    tag: </span><span style="color:#9ECBFF;">&#39;div&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">    props: {</span></span>
<span class="line"><span style="color:#E1E4E8;">      id: </span><span style="color:#9ECBFF;">&#39;foo&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">      class: cls</span></span>
<span class="line"><span style="color:#E1E4E8;">    },</span></span>
<span class="line"><span style="color:#E1E4E8;">    patchFlags: </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> </span><span style="color:#6A737D;">// 假设数字 1 代表 class 是动态的</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">render</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    tag: </span><span style="color:#032F62;">&#39;div&#39;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">    props: {</span></span>
<span class="line"><span style="color:#24292E;">      id: </span><span style="color:#032F62;">&#39;foo&#39;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">      class: cls</span></span>
<span class="line"><span style="color:#24292E;">    },</span></span>
<span class="line"><span style="color:#24292E;">    patchFlags: </span><span style="color:#005CC5;">1</span><span style="color:#24292E;"> </span><span style="color:#6A737D;">// 假设数字 1 代表 class 是动态的</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>在生成的虚拟 DOM 对象中多出了一个 <code>patchFlags</code> 属性，我们假设数字 1 代表“ class 是动态的”，这样渲 染器看到这个标志时就知道：“哦，原来只有 class 属性会发生改 变。”对于渲染器来说，就相当于省去了寻找变更点的工作量，性能自 然就提升了。 通过这个例子，我们了解到编译器和渲染器之间是存在信息交流 的，它们互相配合使得性能进一步提升，而它们之间交流的媒介就是 虚拟 DOM 对象。</p>`,31),e=[o];function t(c,r,E,i,y,d){return a(),n("div",null,e)}const g=s(p,[["render",t]]);export{u as __pageData,g as default};
