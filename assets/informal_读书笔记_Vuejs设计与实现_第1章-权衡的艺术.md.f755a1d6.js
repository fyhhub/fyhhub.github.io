import{_ as s,o as a,c as l,Q as o}from"./chunks/framework.3d945e71.js";const g=JSON.parse('{"title":"第1章-权衡的艺术","description":"","frontmatter":{"order":0},"headers":[],"relativePath":"informal/读书笔记/Vuejs设计与实现/第1章-权衡的艺术.md","filePath":"informal/读书笔记/Vuejs设计与实现/第1章-权衡的艺术.md","lastUpdated":1712884586000}'),n={name:"informal/读书笔记/Vuejs设计与实现/第1章-权衡的艺术.md"},p=o(`<h1 id="第1章-权衡的艺术" tabindex="-1">第1章-权衡的艺术 <a class="header-anchor" href="#第1章-权衡的艺术" aria-label="Permalink to &quot;第1章-权衡的艺术&quot;">​</a></h1><h2 id="_1-1-命令式和声明式" tabindex="-1">1.1 命令式和声明式 <a class="header-anchor" href="#_1-1-命令式和声明式" aria-label="Permalink to &quot;1.1 命令式和声明式&quot;">​</a></h2><p>从范式上来看，视图层框架通常分为命令式和声明式，它们各有优缺点</p><ul><li><p><strong>命令式</strong></p><p>例子：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">div</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> document.</span><span style="color:#B392F0;">querySelector</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;#app&#39;</span><span style="color:#E1E4E8;">) </span><span style="color:#6A737D;">// 获取 div</span></span>
<span class="line"><span style="color:#E1E4E8;">div.innerText </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;hello world&#39;</span><span style="color:#E1E4E8;"> </span><span style="color:#6A737D;">// 设置文本内容</span></span>
<span class="line"><span style="color:#E1E4E8;">div.</span><span style="color:#B392F0;">addEventListener</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;click&#39;</span><span style="color:#E1E4E8;">, () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> { </span><span style="color:#B392F0;">alert</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;ok&#39;</span><span style="color:#E1E4E8;">) })</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">div</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> document.</span><span style="color:#6F42C1;">querySelector</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;#app&#39;</span><span style="color:#24292E;">) </span><span style="color:#6A737D;">// 获取 div</span></span>
<span class="line"><span style="color:#24292E;">div.innerText </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;hello world&#39;</span><span style="color:#24292E;"> </span><span style="color:#6A737D;">// 设置文本内容</span></span>
<span class="line"><span style="color:#24292E;">div.</span><span style="color:#6F42C1;">addEventListener</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;click&#39;</span><span style="color:#24292E;">, () </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> { </span><span style="color:#6F42C1;">alert</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;ok&#39;</span><span style="color:#24292E;">) })</span></span></code></pre></div><p>可以看到，自然语言描述能够与代码产生一一对应的关系，代码本身描述的是“做事的过程”，这符合我们的逻辑直觉。</p></li><li><p><strong>声明式</strong></p><p>例子：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">div</span><span style="color:#E1E4E8;"> </span><span style="color:#FDAEB7;font-style:italic;">@click=&quot;()</span><span style="color:#E1E4E8;"> </span><span style="color:#FDAEB7;font-style:italic;">=&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#FDAEB7;font-style:italic;">alert(&#39;ok&#39;)&quot;&gt;hello</span><span style="color:#E1E4E8;"> </span><span style="color:#FDAEB7;font-style:italic;">world&lt;/div&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">div</span><span style="color:#24292E;"> </span><span style="color:#B31D28;font-style:italic;">@click=&quot;()</span><span style="color:#24292E;"> </span><span style="color:#B31D28;font-style:italic;">=&gt;</span><span style="color:#24292E;"> </span><span style="color:#B31D28;font-style:italic;">alert(&#39;ok&#39;)&quot;&gt;hello</span><span style="color:#24292E;"> </span><span style="color:#B31D28;font-style:italic;">world&lt;/div&gt;</span></span></code></pre></div><p>可以看到，我们提供的是一个“结果”，至于如何实现这个“结果”，我们并不关心。所以它是一个声明式的代码。</p></li></ul><h2 id="_1-2-性能与可维护性的权衡" tabindex="-1">1.2 性能与可维护性的权衡 <a class="header-anchor" href="#_1-2-性能与可维护性的权衡" aria-label="Permalink to &quot;1.2 性能与可维护性的权衡&quot;">​</a></h2><p>结论：<strong>声明式代码的性能不优于命令式代码的性能。</strong></p><p><strong>声明式代码的更新性能消耗 = 找出差异的性能消耗 + 直接修改的性能消耗</strong></p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">div.textContent </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;hello vue3&#39;</span><span style="color:#E1E4E8;"> </span><span style="color:#6A737D;">// 直接修改</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">div.textContent </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;hello vue3&#39;</span><span style="color:#24292E;"> </span><span style="color:#6A737D;">// 直接修改</span></span></code></pre></div><p>VS</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">&lt;!-- 之前： --&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">div</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">@click</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;() =&gt; alert(&#39;ok&#39;)&quot;</span><span style="color:#E1E4E8;">&gt;hello world&lt;/</span><span style="color:#85E89D;">div</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#6A737D;">&lt;!-- 之后： --&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">div</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">@click</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;() =&gt; alert(&#39;ok&#39;)&quot;</span><span style="color:#E1E4E8;">&gt;hello vue3&lt;/</span><span style="color:#85E89D;">div</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">&lt;!-- 之前： --&gt;</span></span>
<span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">div</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">@click</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;() =&gt; alert(&#39;ok&#39;)&quot;</span><span style="color:#24292E;">&gt;hello world&lt;/</span><span style="color:#22863A;">div</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#6A737D;">&lt;!-- 之后： --&gt;</span></span>
<span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">div</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">@click</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;() =&gt; alert(&#39;ok&#39;)&quot;</span><span style="color:#24292E;">&gt;hello vue3&lt;/</span><span style="color:#22863A;">div</span><span style="color:#24292E;">&gt;</span></span></code></pre></div><p>可以发现直接修改<code>textContent</code>的性能肯定是优于<code>声明式</code>的。因为声明式框架还要经过<code>框架运行时</code>的过程。</p><h2 id="_1-3-虚拟-dom-的性能到底如何" tabindex="-1">1.3 虚拟 DOM 的性能到底如何 <a class="header-anchor" href="#_1-3-虚拟-dom-的性能到底如何" aria-label="Permalink to &quot;1.3 虚拟 DOM 的性能到底如何&quot;">​</a></h2><p>在大部分情况下，我们很难写出绝对优化的命令式代码，尤其是当应用程序的规模很大的时候，即使你写出了极致优化的代码，也一定耗费了巨大的精力，这时的投入产出比其实并不高。</p><p>innerHTML 和虚拟 DOM 在创建页面时的性能</p><p><img src="https://raw.githubusercontent.com/fyhhub/imgs/main/imgs20220907193611.png" alt="20220907193611"></p><h2 id="_1-4-运行时和编译时" tabindex="-1">1.4 运行时和编译时 <a class="header-anchor" href="#_1-4-运行时和编译时" aria-label="Permalink to &quot;1.4 运行时和编译时&quot;">​</a></h2><ul><li><p><strong>纯运行时</strong></p><p>不需要任何编译，直接运行代码，就是运行时。比如你使用react，但不使用jsx语法，直接手写React.createElement，这就少了编译的步骤，可以直接运行代码。</p></li><li><p><strong>纯编译时</strong></p><p>需要对代码编译后，才能运行，就是编译时。例如Svelte框架, 你需要按照Svelte提供的dsl语法来写代码，经过编译后才运行。</p></li><li><p><strong>运行时编译</strong></p><p>代码在运行的时候编译，然后执行。例如我们用vue打包后的代码<code>vue.global.js</code>。这个文件中就包含了<code>compileTemplate</code>的代码。我们执行代码的过程中，还要经过编译，最后执行。</p></li><li><p><strong>编译时 + 运行时</strong></p><p>需要先经过打包工具对你的代码进行编译。然后在运行的时候就不需要编译了，直接执行。例如vue-loader,在项目冷启动或hmr的时候进行编译。</p></li></ul>`,17),t=[p];function e(c,r,i,E,y,d){return a(),l("div",null,t)}const u=s(n,[["render",e]]);export{g as __pageData,u as default};
