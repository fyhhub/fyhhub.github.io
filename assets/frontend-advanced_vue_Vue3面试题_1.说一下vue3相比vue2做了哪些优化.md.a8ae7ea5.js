import{_ as e,o as a,c as o,Q as t}from"./chunks/framework.353e5930.js";const h=JSON.parse('{"title":"1.说一下vue3相比vue2做了哪些优化.md","description":"","frontmatter":{"order":1},"headers":[],"relativePath":"frontend-advanced/vue/Vue3面试题/1.说一下vue3相比vue2做了哪些优化.md","filePath":"frontend-advanced/vue/Vue3面试题/1.说一下vue3相比vue2做了哪些优化.md"}'),i={name:"frontend-advanced/vue/Vue3面试题/1.说一下vue3相比vue2做了哪些优化.md"},r=t('<h1 id="_1-说一下vue3相比vue2做了哪些优化-md" tabindex="-1">1.说一下vue3相比vue2做了哪些优化.md <a class="header-anchor" href="#_1-说一下vue3相比vue2做了哪些优化-md" aria-label="Permalink to &quot;1.说一下vue3相比vue2做了哪些优化.md&quot;">​</a></h1><h2 id="源码优化" tabindex="-1">源码优化 <a class="header-anchor" href="#源码优化" aria-label="Permalink to &quot;源码优化&quot;">​</a></h2><ol><li>更好的代码管理方式：monorepo</li><li>有类型的 JavaScript：TypeScript</li></ol><h2 id="性能优化" tabindex="-1">性能优化 <a class="header-anchor" href="#性能优化" aria-label="Permalink to &quot;性能优化&quot;">​</a></h2><ol><li>源码体积优化</li></ol><ul><li>移除一些冷门的 feature（比如 filter、inline-template 等）</li><li>引入 tree-shaking 的技术，减少打包体积</li></ul><ol start="2"><li><p>数据劫持优化 Vue2 中对一个深层的对象会递归 Object.defineProperty 把每一层对象数据都变成响应式的， 而在 Vue 3.0 只有在触发 getter 时才会递归处理成响应式</p></li><li><p>编译优化 通过编译阶段对静态模板的分析，编译生成了 <code>Block tree</code>。<code>Block tree</code> 是一个将模版基于动态节点指令切割的嵌套区块，每个区块内部的节点结构是固定的，而且每个区块只需要以一个 Array 来追踪自身包含的动态节点。借助 Block tree，Vue.js 将 vnode 更新性能由与模版整体大小相关提升为与动态内容的数量相关，这是一个非常大的性能突破</p></li><li><p>v-memo 优化渲染，只有当它依赖的值发生改变，才会重新创建 VNode，以及重新渲染子节点， 否则整个 VNode 的创建和更新都会被跳过</p></li><li><p>除此之外，Vue.js 3.0 在编译阶段还包含了对 Slot 的编译优化、事件侦听函数的缓存优化，并且在运行时重写了 diff 算法</p></li></ol><h2 id="语法-api-优化-composition-api" tabindex="-1">语法 API 优化：Composition API <a class="header-anchor" href="#语法-api-优化-composition-api" aria-label="Permalink to &quot;语法 API 优化：Composition API&quot;">​</a></h2>',8),l=[r];function d(n,u,c,_,s,p){return a(),o("div",null,l)}const m=e(i,[["render",d]]);export{h as __pageData,m as default};
