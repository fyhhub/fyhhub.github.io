import{_ as e,o as a,c as t,Q as o}from"./chunks/framework.3d945e71.js";const R=JSON.parse('{"title":"React 理念","description":"","frontmatter":{},"headers":[],"relativePath":"frontend-advanced/React/React原理/React理念.md","filePath":"frontend-advanced/React/React原理/React理念.md","lastUpdated":1694138900000}'),c={name:"frontend-advanced/React/React原理/React理念.md"},d=o('<h1 id="react-理念" tabindex="-1">React 理念 <a class="header-anchor" href="#react-理念" aria-label="Permalink to &quot;React 理念&quot;">​</a></h1><h2 id="cpu-瓶颈" tabindex="-1">CPU 瓶颈 <a class="header-anchor" href="#cpu-瓶颈" aria-label="Permalink to &quot;CPU 瓶颈&quot;">​</a></h2><p><strong>原因:</strong></p><p>JS 可以操作 DOM，<code>GUI渲染线程</code>和<code>JS线程</code>是互斥的,所以 JS 脚本执行和浏览器布局、绘制不能同时执行。 当 JS 执行时间太长，就会导致页面卡顿</p><p><strong>如何解决:</strong></p><p>在浏览器每一帧的时间中，预留一些时间给 JS 线程, 利用这些时间更新组件。当一帧中的任务无法完成，就会中断更新，放在下一帧执行。</p><p>所以，解决该问题的关键是，实现<code>时间切片</code>, 将<code>同步的更新</code>变为<code>可中断的异步更新</code>。</p><h2 id="io-瓶颈" tabindex="-1">IO 瓶颈 <a class="header-anchor" href="#io-瓶颈" aria-label="Permalink to &quot;IO 瓶颈&quot;">​</a></h2><p><code>React</code> 将人机交互研究的结果整合到真实的 UI 中。</p><p>例如当我们访问 github 某个页面，页面并没有直接跳转，而是留在当前页面，等待数据加载完成。</p><p>为此，React 实现了<code>Suspense (opens new window)</code>功能及配套的 hook——<code>useDeferredValue</code> (opens new window)。</p><p>而在源码内部，为了支持这些特性，同样需要<code>将同步的更新变为可中断的异步更新</code></p>',12),n=[d];function r(s,p,i,_,h,l){return a(),t("div",null,n)}const f=e(c,[["render",r]]);export{R as __pageData,f as default};
