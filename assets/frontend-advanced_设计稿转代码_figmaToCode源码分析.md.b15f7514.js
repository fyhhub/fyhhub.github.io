import{_ as l,o as s,c as a,Q as o}from"./chunks/framework.3d945e71.js";const u=JSON.parse('{"title":"figmaToCode 源码分析","description":"","frontmatter":{},"headers":[],"relativePath":"frontend-advanced/设计稿转代码/figmaToCode源码分析.md","filePath":"frontend-advanced/设计稿转代码/figmaToCode源码分析.md","lastUpdated":1700360004000}'),e={name:"frontend-advanced/设计稿转代码/figmaToCode源码分析.md"},n=o(`<h1 id="figmatocode-源码分析" tabindex="-1">figmaToCode 源码分析 <a class="header-anchor" href="#figmatocode-源码分析" aria-label="Permalink to &quot;figmaToCode 源码分析&quot;">​</a></h1><h3 id="blend-是什么" tabindex="-1">blend 是什么 <a class="header-anchor" href="#blend-是什么" aria-label="Permalink to &quot;blend 是什么&quot;">​</a></h3><p>在 Figma 中，blend 是一个用于设置图层混合模式的属性。图层混合模式决定了图层与下方图层的颜色如何混合。blend 属性可以设置为以下值之一：</p><p>&quot;NORMAL&quot;：正常模式，即不进行混合。 &quot;DARKEN&quot;：变暗模式，将图层颜色与下方图层颜色进行比较，选取较暗的颜色作为混合结果。 &quot;MULTIPLY&quot;：正片叠底模式，将图层颜色与下方图层颜色进行相乘，得到混合结果。 &quot;COLOR_BURN&quot;：颜色加深模式，将下方图层颜色除以图层颜色的补色，得到混合结果。 &quot;LIGHTEN&quot;：变亮模式，将图层颜色与下方图层颜色进行比较，选取较亮的颜色作为混合结果。 &quot;SCREEN&quot;：滤色模式，将图层颜色与下方图层颜色进行相反操作，得到混合结果。 &quot;COLOR_DODGE&quot;：颜色减淡模式，将下方图层颜色除以图层颜色，得到混合结果。 &quot;OVERLAY&quot;：叠加模式，将图层颜色与下方图层颜色进行比较，选取较亮的颜色作为混合结果。 &quot;SOFT_LIGHT&quot;：柔光模式，将图层颜色与下方图层颜色进行比较，根据图层颜色的亮度调整下方图层颜色的亮度，得到混合结果。 &quot;HARD_LIGHT&quot;：强光模式，将图层颜色与下方图层颜色进行比较，根据下方图层颜色的亮度调整图层颜色的亮度，得到混合结果。 &quot;DIFFERENCE&quot;：差值模式，将图层颜色与下方图层颜色进行相减，得到混合结果。 &quot;EXCLUSION&quot;：排除模式，将图层颜色与下方图层颜色进行相减并取绝对值，得到混合结果。 &quot;HUE&quot;：色相模式，将图层颜色的色相与下方图层颜色的亮度和饱和度进行混合，得到混合结果。 &quot;SATURATION&quot;：饱和度模式，将图层颜色的饱和度与下方图层颜色的亮度和色相进行混合，得到混合结果。 &quot;COLOR&quot;：颜色模式，将图层颜色的色相和饱和度与下方图层颜色的亮度进行混合，得到混合结果。 &quot;LUMINOSITY&quot;：亮度模式，将图层颜色的亮度与下方图层颜色的色相和饱和度进行混合，得到混合结果。 blend 属性可以通过 Figma 的图层属性面板或代码中进行设置。</p><h3 id="effects-是什么" tabindex="-1">effects 是什么 <a class="header-anchor" href="#effects-是什么" aria-label="Permalink to &quot;effects 是什么&quot;">​</a></h3><p>在 Figma 中，effects 是一种图层样式，用于添加<code>阴影、发光、模糊等效果</code>。effects 可以应用于任何图层类型，包括矩形、文本、图像等。每个 effect 都有一个类型和一组属性，用于控制效果的外观和行为。</p><p>effects 可以通过 Figma 的图层属性面板或代码中进行设置。在代码中，可以使用 Figma API 中的 setEffectsAsync 方法来设置图层的 effects。例如，以下代码将一个矩形图层的阴影效果设置为黑色、偏移量为 (0, 4)、模糊半径为 4：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">rect</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> figma.</span><span style="color:#B392F0;">createRectangle</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">rect.effects </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> [</span></span>
<span class="line"><span style="color:#E1E4E8;">  {</span></span>
<span class="line"><span style="color:#E1E4E8;">    type: </span><span style="color:#9ECBFF;">&#39;DROP_SHADOW&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">    color: { r: </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, g: </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, b: </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, a: </span><span style="color:#79B8FF;">0.5</span><span style="color:#E1E4E8;"> },</span></span>
<span class="line"><span style="color:#E1E4E8;">    offset: { x: </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, y: </span><span style="color:#79B8FF;">4</span><span style="color:#E1E4E8;"> },</span></span>
<span class="line"><span style="color:#E1E4E8;">    radius: </span><span style="color:#79B8FF;">4</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">    visible: </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">    blendMode: </span><span style="color:#9ECBFF;">&#39;NORMAL&#39;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">];</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">rect</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> figma.</span><span style="color:#6F42C1;">createRectangle</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">rect.effects </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> [</span></span>
<span class="line"><span style="color:#24292E;">  {</span></span>
<span class="line"><span style="color:#24292E;">    type: </span><span style="color:#032F62;">&#39;DROP_SHADOW&#39;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">    color: { r: </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, g: </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, b: </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, a: </span><span style="color:#005CC5;">0.5</span><span style="color:#24292E;"> },</span></span>
<span class="line"><span style="color:#24292E;">    offset: { x: </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, y: </span><span style="color:#005CC5;">4</span><span style="color:#24292E;"> },</span></span>
<span class="line"><span style="color:#24292E;">    radius: </span><span style="color:#005CC5;">4</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">    visible: </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">    blendMode: </span><span style="color:#032F62;">&#39;NORMAL&#39;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">];</span></span></code></pre></div><h3 id="effectstyleid-是什么" tabindex="-1">effectStyleId 是什么 <a class="header-anchor" href="#effectstyleid-是什么" aria-label="Permalink to &quot;effectStyleId 是什么&quot;">​</a></h3><p>effectStyleId 是 Figma 中的一个属性，它表示一个图层的效果样式 ID。效果样式是一组效果的集合，可以应用于多个图层。如果一个图层应用了一个效果样式，那么它的 effectStyleId 属性将指向该效果样式的 ID</p><h3 id="fills-是什么" tabindex="-1">fills 是什么 <a class="header-anchor" href="#fills-是什么" aria-label="Permalink to &quot;fills 是什么&quot;">​</a></h3><p>fills 是一个用于设置节点填充的属性。它是一个数组，每个元素表示节点的一个填充。每个填充都有一个类型和一组属性，用于控制填充的外观和行为。</p><p>fills 可以包含多个填充，每个填充可以是以下类型之一：</p><p>&quot;SOLID&quot;：纯色填充，使用单一颜色填充节点。 &quot;GRADIENT_LINEAR&quot;：线性渐变填充，使用两种或多种颜色之间的线性渐变填充节点。 &quot;GRADIENT_RADIAL&quot;：径向渐变填充，使用两种或多种颜色之间的径向渐变填充节点。 &quot;GRADIENT_ANGULAR&quot;：角度渐变填充，使用两种或多种颜色之间的角度渐变填充节点。 &quot;GRADIENT_DIAMOND&quot;：菱形渐变填充，使用两种或多种颜色之间的菱形渐变填充节点。 &quot;IMAGE&quot;：图像填充，使用图像填充节点。</p><h3 id="源码流程" tabindex="-1">源码流程 <a class="header-anchor" href="#源码流程" aria-label="Permalink to &quot;源码流程&quot;">​</a></h3><h4 id="一、拷贝整体结构-并记录和处理节点中的信息" tabindex="-1">一、拷贝整体结构，并记录和处理节点中的信息 <a class="header-anchor" href="#一、拷贝整体结构-并记录和处理节点中的信息" aria-label="Permalink to &quot;一、拷贝整体结构，并记录和处理节点中的信息&quot;">​</a></h4><ol><li><p>获取选中部分的 figma 节点数据</p></li><li><p>开始转换节点，遍历每个 figma 节点</p><ol><li><p>如果节点类型是 RECTANGLE、ELLIPSE</p><ol><li>是 RECTANGLE 就 创建 RECTANGLE Node 节点，并记录 figma 节点中的圆角 radius</li><li>是 ELLIPSE 就创建 ELLIPSE Node 节点</li><li>记录 figma node 的 name 和 id</li><li>记录 figma node 的 parentId</li><li>记录 figma node 的 opacity、blendMode、isMask、effects、effectStyleId、visible</li><li>记录 figma node 的 几何形状，fills、strokes、strokeWeight、strokeMiterLimit、strokeAlign、strokeCap、strokeJoin、dashPattern、fillStyleId、strokeStyleId</li><li>记录 figma node 的 布局位置 <ol><li>判断 node 是否存在旋转角度，并获取真实的 x, y 值</li><li>记录 x,y,width,height 等</li></ol></li><li>记录 figma node 的 cornerSmoothing（节点的圆角平滑度），cornerRadius（圆角的大小）</li><li>返回新节点</li></ol></li><li><p>如果节点类型是 LINE</p><ol><li>创建 RECTANGLE Node 节点</li><li>重复 2.1.3 ~ 2.1.8 操作</li><li>强制修改 height = 1, strokeAlign = &#39;CENTER&#39;, strokeWeight - 1</li><li>返回新节点</li></ol></li><li><p>如果节点类型是 FRAME、INSTANCE、COMPONENT</p><ol><li>将图标转为 RECTANGLE 节点 <ol><li>遍历所有子节点，判断是否全部都是 VECTOR 类型的节点，则执行以下操作</li><li>重复 2.1.3 ~ 2.1.7 操作</li><li>强制修改节点信息，strokes = [], strokeWeight = 0, strokeMiterLimit = 0, strokeAlign = &quot;CENTER&quot;, strokeCap = &quot;NONE&quot;, strokeJoin = &quot;BEVEL&quot;, dashPattern = [], fillStyleId = &quot;&quot;, strokeStyleId = &quot;&quot;。填充为 IMAGE 类型</li><li>返回 RECTANGLE Node</li></ol></li><li>如果不是图标节点，则开始 Frame 下的子节点 <ol><li>如果没有子节点，直接返回一个新的 RECTANGLE Node， 操作同 2.1</li><li>创建 Frame Node</li><li>重复 2.1.3 ~ 2.1.8 操作</li><li>记录 figma node 的 radius 信息</li></ol></li><li>递归回到 2 步骤</li><li>递归完成后，重复 2.4.6 步骤</li><li>递归完成后，开始为当前节点实现自动布局 <ol><li>如果当前节点 layoutMode 存在有效的值，说明 UI 已经实现了自动布局，不需要自己计算了，则后续步骤不会执行</li><li>对当前节点的子节点 children 进行排序，获取子节点的排布方向，以及子节点之间的平均间距 <ol><li>根据位置，判断子节点是 垂直还是水平排布 以及 子节点之间的间距 <ol><li>计算子节点 水平方向上的平均间距</li><li>计算子节点 垂直方向上的平均间距</li></ol></li><li>如果是 水平，用 x 坐标进行排序</li><li>如果是 垂直，用 y 坐标排序</li></ol></li><li>如果没有计算出来方向，并且不止一个子节点，节点标记 isRelative = true</li><li>如果没有计算出来方向，节点数量 === 0 或者 节点数量 &gt; 1， 直接返回 node 即可</li><li>如果当前节点的类型是 group, 强制转成 frame 节点</li><li>如果没有计算出来方向，节点数量 === 1，就设置一个默认方向： HORIZONTAL</li><li>开始计算节点的 padding <ol><li>如果只有一个子节点，计算出子节点在当前节点内容，left, top, right, bottom 距离</li><li>如果有多个节点，计算 padding</li></ol></li><li>开始计算子节点的 align-items 布局对齐 <ol><li>判断子节点的宽度或高度 是不是存在跟父节点一样，则说明子节点 在水平或垂直方向上，align 是 STRETCH 布局</li><li>否则直接设置为 INHERIT</li></ol></li><li>开始计算每个子节点在 主轴和交叉轴的对齐方式（justify-content, align-items）, 返回一个对象{primary: MIN/MAX/CENTER,counter: MIN/MAX/CENTER} 10.知道每个子节点的对齐方式，我们可以统计出，主轴、交叉轴上，出现频率最高的对齐方式</li><li></li></ol></li></ol></li><li><p>如果节点类型是 GROUP</p><ol><li>如果只有一个节点，递归重复 2 步骤</li><li>重复 2.3.1 步骤</li><li>创建 Group Node</li><li>重复 2.1.3 ~ 2.1.7 操作</li><li>遍历子节点，递归重复 2 步骤</li><li>遍历子节点，并将这些矩形转换为包含这些节点的 Frame 节点 <ol><li>小于两个节点，无需后续步骤</li><li>执行 retrieveCollidingItems 查找在同一父级下的矩形节点之间的重叠情况，最后返回一个对象。其中键是矩形节点的 ID，值是与该节点重叠的其他矩形节点的数组。</li><li>找到 非交叉的节点</li><li>将当前节点强制转成 frame 节点</li><li>将交叉节点，全部塞到刚才强制转成的 frame 节点中，然后计算交叉的节点，相对 frame 的 x 和 y 的值</li><li>更新节点，重复 2.3.5 自动布局刚才的 frame 节点</li><li>然后布局整体节点</li></ol></li></ol></li><li><p>如果节点类型是 TEXT</p><ol><li>略。。很简单</li></ol></li><li><p>如果节点类型是 VECTOR</p><ol><li>略，跟 RECTANGLE 节点相似</li></ol></li></ol></li></ol>`,17),t=[n];function i(p,r,c,E,d,y){return s(),a("div",null,t)}const q=l(e,[["render",i]]);export{u as __pageData,q as default};
