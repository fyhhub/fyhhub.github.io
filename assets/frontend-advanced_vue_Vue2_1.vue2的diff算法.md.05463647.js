import{_ as s,o as n,c as a,Q as p}from"./chunks/framework.3d945e71.js";const f=JSON.parse('{"title":"1.vue2 的 diff 算法","description":"","frontmatter":{"order":1},"headers":[],"relativePath":"frontend-advanced/vue/Vue2/1.vue2的diff算法.md","filePath":"frontend-advanced/vue/Vue2/1.vue2的diff算法.md","lastUpdated":1697505816000}'),l={name:"frontend-advanced/vue/Vue2/1.vue2的diff算法.md"},o=p(`<h1 id="_1-vue2-的-diff-算法" tabindex="-1">1.vue2 的 diff 算法 <a class="header-anchor" href="#_1-vue2-的-diff-算法" aria-label="Permalink to &quot;1.vue2 的 diff 算法&quot;">​</a></h1><h3 id="diff-算法过程" tabindex="-1">diff 算法过程 <a class="header-anchor" href="#diff-算法过程" aria-label="Permalink to &quot;diff 算法过程&quot;">​</a></h3><p>diff 算法比较关键的是 sameVnode 判断两个节点是否相同</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 判断两个节点是否相同</span></span>
<span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">sameVnode</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">a</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">b</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> (</span></span>
<span class="line"><span style="color:#E1E4E8;">    a.key </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> b.key </span><span style="color:#F97583;">&amp;&amp;</span></span>
<span class="line"><span style="color:#E1E4E8;">    a.asyncFactory </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> b.asyncFactory </span><span style="color:#F97583;">&amp;&amp;</span></span>
<span class="line"><span style="color:#E1E4E8;">    ((a.tag </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> b.tag </span><span style="color:#F97583;">&amp;&amp;</span></span>
<span class="line"><span style="color:#E1E4E8;">      a.isComment </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> b.isComment </span><span style="color:#F97583;">&amp;&amp;</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#B392F0;">isDef</span><span style="color:#E1E4E8;">(a.data) </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">isDef</span><span style="color:#E1E4E8;">(b.data) </span><span style="color:#F97583;">&amp;&amp;</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#B392F0;">sameInputType</span><span style="color:#E1E4E8;">(a, b)) </span><span style="color:#F97583;">||</span></span>
<span class="line"><span style="color:#E1E4E8;">      (</span><span style="color:#B392F0;">isTrue</span><span style="color:#E1E4E8;">(a.isAsyncPlaceholder) </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">isUndef</span><span style="color:#E1E4E8;">(b.asyncFactory.error)))</span></span>
<span class="line"><span style="color:#E1E4E8;">  );</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 判断两个节点是否相同</span></span>
<span class="line"><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">sameVnode</span><span style="color:#24292E;">(</span><span style="color:#E36209;">a</span><span style="color:#24292E;">, </span><span style="color:#E36209;">b</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> (</span></span>
<span class="line"><span style="color:#24292E;">    a.key </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> b.key </span><span style="color:#D73A49;">&amp;&amp;</span></span>
<span class="line"><span style="color:#24292E;">    a.asyncFactory </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> b.asyncFactory </span><span style="color:#D73A49;">&amp;&amp;</span></span>
<span class="line"><span style="color:#24292E;">    ((a.tag </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> b.tag </span><span style="color:#D73A49;">&amp;&amp;</span></span>
<span class="line"><span style="color:#24292E;">      a.isComment </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> b.isComment </span><span style="color:#D73A49;">&amp;&amp;</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6F42C1;">isDef</span><span style="color:#24292E;">(a.data) </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">isDef</span><span style="color:#24292E;">(b.data) </span><span style="color:#D73A49;">&amp;&amp;</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6F42C1;">sameInputType</span><span style="color:#24292E;">(a, b)) </span><span style="color:#D73A49;">||</span></span>
<span class="line"><span style="color:#24292E;">      (</span><span style="color:#6F42C1;">isTrue</span><span style="color:#24292E;">(a.isAsyncPlaceholder) </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">isUndef</span><span style="color:#24292E;">(b.asyncFactory.error)))</span></span>
<span class="line"><span style="color:#24292E;">  );</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p><strong>while(旧首指针 &lt;= 旧尾指针 &amp;&amp; 新首指针 &lt;= 新尾指针) {</strong></p><ol><li><p><strong>旧首节点如果不存在</strong>，旧首指针<code>向右移动1位</code></p></li><li><p><strong>旧尾节点如果不存在</strong>，旧尾指针<code>向左移动1位</code></p></li><li><p><strong>旧首节点和新首节点</strong> <code>sameVnode</code> 对比相同，继续递归<code>patch</code>子节点，旧首指针<code>向右移动1位</code>，新首指针<code>向右移动1位</code></p></li><li><p><strong>旧尾节点和新尾节点</strong> <code>sameVnode</code> 对比相同，继续递归<code>patch</code>子节点，旧尾指针<code>向左移动1位</code>，新尾指针<code>向左移动1位</code></p></li><li><p><strong>旧首节点和新尾节点</strong> <code>sameVnode</code> 对比相同，继续递归<code>patch</code>子节点，将<strong>旧首结点</strong>移动到尾部，旧首指针<code>向右移动1位</code>， 新尾指针<code>向左移动1位</code></p></li><li><p><strong>旧尾结点和新首节点</strong> <code>sameVnode</code> 对比相同，继续递归<code>patch</code>子节点，将<strong>旧尾结点</strong>移动到首部，旧尾指针<code>向左移动1位</code>， 新首指针<code>向右移动1位</code></p></li><li><p>以上都未满足，根据旧列表节点创建<code>Map{key =&gt; index}</code>，拿到<strong>新首节点</strong>的 key, 判断在<code>key map</code>中存在，<strong>如果有获取其索引直接使用，否则需要遍历旧节点列表</strong>，找到索引，这也是<strong>diff 算法中 key 的作用</strong></p></li></ol><p>8.如果仍然没有拿到新节点在旧列表中的索引，说明是全新节点，需要继续创建</p><p>9.如果拿到索引，对应索引上的节点和新节点 <code>sameVnode</code> 进行对比，如果相同，则需要移动位置或者继续递归对比更新；否则需要创建新节点；</p><ol start="10"><li><p>新首指针<code>向右移动1位</code></p></li><li><p>最后不管什么情况都会执行如下代码</p></li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (oldStartIdx </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> oldEndIdx) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  refElm </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">isUndef</span><span style="color:#E1E4E8;">(newCh[newEndIdx </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">]) </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> newCh[newEndIdx </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">].elm;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">addVnodes</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">    parentElm,</span></span>
<span class="line"><span style="color:#E1E4E8;">    refElm,</span></span>
<span class="line"><span style="color:#E1E4E8;">    newCh,</span></span>
<span class="line"><span style="color:#E1E4E8;">    newStartIdx,</span></span>
<span class="line"><span style="color:#E1E4E8;">    newEndIdx,</span></span>
<span class="line"><span style="color:#E1E4E8;">    insertedVnodeQueue</span></span>
<span class="line"><span style="color:#E1E4E8;">  );</span></span>
<span class="line"><span style="color:#E1E4E8;">} </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (newStartIdx </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> newEndIdx) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">removeVnodes</span><span style="color:#E1E4E8;">(oldCh, oldStartIdx, oldEndIdx);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (oldStartIdx </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> oldEndIdx) {</span></span>
<span class="line"><span style="color:#24292E;">  refElm </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">isUndef</span><span style="color:#24292E;">(newCh[newEndIdx </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">]) </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> newCh[newEndIdx </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">].elm;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">addVnodes</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">    parentElm,</span></span>
<span class="line"><span style="color:#24292E;">    refElm,</span></span>
<span class="line"><span style="color:#24292E;">    newCh,</span></span>
<span class="line"><span style="color:#24292E;">    newStartIdx,</span></span>
<span class="line"><span style="color:#24292E;">    newEndIdx,</span></span>
<span class="line"><span style="color:#24292E;">    insertedVnodeQueue</span></span>
<span class="line"><span style="color:#24292E;">  );</span></span>
<span class="line"><span style="color:#24292E;">} </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (newStartIdx </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> newEndIdx) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">removeVnodes</span><span style="color:#24292E;">(oldCh, oldStartIdx, oldEndIdx);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>不断对比的过程使得 oldStartIndex 不断逼近 oldEndIndex，newStartIndex 不断逼近 newEndIndex。当<strong>旧尾结点 &lt;= 旧首节点</strong>说明<code>旧节点已经遍历完了</code>，此时只要批量增加新节点即可。当<strong>新尾结点 &lt;= 新首节点</strong> 说明<code>旧节点还有剩下</code>，此时只要批量删除旧节点即可</p>`,11),e=[o];function c(t,r,E,y,d,i){return n(),a("div",null,e)}const F=s(l,[["render",c]]);export{f as __pageData,F as default};
