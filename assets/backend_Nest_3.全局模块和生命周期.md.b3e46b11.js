import{_ as s,o,c as a,Q as n}from"./chunks/framework.3d945e71.js";const y=JSON.parse('{"title":"全局模块和生命周期","description":"","frontmatter":{},"headers":[],"relativePath":"backend/Nest/3.全局模块和生命周期.md","filePath":"backend/Nest/3.全局模块和生命周期.md","lastUpdated":1730984667000}'),e={name:"backend/Nest/3.全局模块和生命周期.md"},l=n(`<h1 id="全局模块和生命周期" tabindex="-1">全局模块和生命周期 <a class="header-anchor" href="#全局模块和生命周期" aria-label="Permalink to &quot;全局模块和生命周期&quot;">​</a></h1><h2 id="全局模块" tabindex="-1">全局模块 <a class="header-anchor" href="#全局模块" aria-label="Permalink to &quot;全局模块&quot;">​</a></h2><p><strong>模块导出 provider，另一个模块需要 <code>imports</code> 它才能用这些 provider。</strong></p><p>如何设置全局的<code>provider</code>呢？可以使用<code>@Golbal()</code> 来声明一个全局模块</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#B392F0;">Golbal</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#B392F0;">Module</span><span style="color:#E1E4E8;">({</span></span>
<span class="line"><span style="color:#E1E4E8;">  providers: [</span></span>
<span class="line"><span style="color:#E1E4E8;">    AaaService,</span></span>
<span class="line"><span style="color:#E1E4E8;">    BbbService</span></span>
<span class="line"><span style="color:#E1E4E8;">  ],</span></span>
<span class="line"><span style="color:#E1E4E8;">  exports: [</span></span>
<span class="line"><span style="color:#E1E4E8;">    AaaService,</span></span>
<span class="line"><span style="color:#E1E4E8;">    BbbService</span></span>
<span class="line"><span style="color:#E1E4E8;">  ]</span></span>
<span class="line"><span style="color:#E1E4E8;">})</span></span>
<span class="line"><span style="color:#F97583;">export</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">AppModule</span><span style="color:#E1E4E8;"> {}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">@</span><span style="color:#6F42C1;">Golbal</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;">@</span><span style="color:#6F42C1;">Module</span><span style="color:#24292E;">({</span></span>
<span class="line"><span style="color:#24292E;">  providers: [</span></span>
<span class="line"><span style="color:#24292E;">    AaaService,</span></span>
<span class="line"><span style="color:#24292E;">    BbbService</span></span>
<span class="line"><span style="color:#24292E;">  ],</span></span>
<span class="line"><span style="color:#24292E;">  exports: [</span></span>
<span class="line"><span style="color:#24292E;">    AaaService,</span></span>
<span class="line"><span style="color:#24292E;">    BbbService</span></span>
<span class="line"><span style="color:#24292E;">  ]</span></span>
<span class="line"><span style="color:#24292E;">})</span></span>
<span class="line"><span style="color:#D73A49;">export</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">AppModule</span><span style="color:#24292E;"> {}</span></span></code></pre></div><p>然后其他模块就不需要<code>imports</code>来导入模块了。可以直接使用它里面的 <code>Service</code></p><h2 id="生命周期" tabindex="-1">生命周期 <a class="header-anchor" href="#生命周期" aria-label="Permalink to &quot;生命周期&quot;">​</a></h2><h3 id="_1-应用初始化阶段" tabindex="-1">1. 应用初始化阶段 <a class="header-anchor" href="#_1-应用初始化阶段" aria-label="Permalink to &quot;1. 应用初始化阶段&quot;">​</a></h3><ol><li><p>递归初始化模块，会依次调用模块内的 controller、provider 的 <code>onModuleInit</code> 方法，然后再调用 module 的 <code>onModuleInit</code> 方法。</p></li><li><p>全部初始化完之后，再依次调用模块内的 controller、provider 的 <code>onApplicationBootstrap</code> 方法，然后调用 module 的 <code>onApplicationBootstrap</code> 方法</p></li></ol><ul><li>onModuleInit 需要实现 OnModuleInit 接口</li><li>onApplicationBootstrap 需要实现 OnApplicationBootstrap 接口</li></ul><h3 id="_2-应用销毁阶段" tabindex="-1">2. 应用销毁阶段 <a class="header-anchor" href="#_2-应用销毁阶段" aria-label="Permalink to &quot;2. 应用销毁阶段&quot;">​</a></h3><ol><li><p>先调用每个模块的 controller、provider 的 <code>onModuleDestroy</code> 方法，然后调用 Module 的 <code>onModuleDestroy</code> 方法。</p></li><li><p>之后再调用每个模块的 controller、provider 的 <code>beforeApplicationShutdown</code> 方法，然后调用 Module 的 <code>beforeApplicationShutdown</code> 方法。</p></li><li><p>停止监听网络端口, 之后调用每个模块的 controller、provider 的<code>onApplicationShutdown</code> 方法，然后调用 Module 的 <code>onApplicationShutdown</code>方法。</p></li></ol><ul><li>onModuleDestroy 需要实现 <code>OnModuleDestroy</code> 接口</li><li>beforeApplicationShutdown 需要实现 <code>BeforeApplicationShutdown</code> 接口</li><li>onApplicationShutdown 需要实现 <code>OnApplicationShutdown</code>接口</li></ul><p><code>beforeApplicationShutdown</code> 和 <code>onApplicationShutdown</code> 区别是，前者可以获取到 signal 系统信号的，比如 SIGTERM</p>`,14),p=[l];function c(t,r,i,d,E,u){return o(),a("div",null,p)}const _=s(e,[["render",c]]);export{y as __pageData,_ as default};
