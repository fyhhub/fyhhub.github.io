import{_ as e,o as a,c,Q as t}from"./chunks/framework.3d945e71.js";const R=JSON.parse('{"title":"React 新老架构对比","description":"","frontmatter":{},"headers":[],"relativePath":"frontend-advanced/React/React原理/React新老架构对比.md","filePath":"frontend-advanced/React/React原理/React新老架构对比.md","lastUpdated":1697505816000}'),d={name:"frontend-advanced/React/React原理/React新老架构对比.md"},l=t('<h1 id="react-新老架构对比" tabindex="-1">React 新老架构对比 <a class="header-anchor" href="#react-新老架构对比" aria-label="Permalink to &quot;React 新老架构对比&quot;">​</a></h1><h2 id="老架构" tabindex="-1">老架构 <a class="header-anchor" href="#老架构" aria-label="Permalink to &quot;老架构&quot;">​</a></h2><p>React15 架构可以分为两层：</p><ul><li><code>Reconciler（协调器）</code>: 负责找出变化的组件</li><li><code>Renderer（渲染器）</code>: 负责将变化的组件渲染到页面上</li></ul><p>缺点：<code>组件更新和渲染，都会递归更新子组件，当层级很深时，超过16ms, 页面就会卡顿</code></p><h2 id="新架构" tabindex="-1">新架构 <a class="header-anchor" href="#新架构" aria-label="Permalink to &quot;新架构&quot;">​</a></h2><p>React16 架构可以分为三层：</p><ul><li><code>Scheduler（调度器）</code>: 调度任务的优先级，高优任务优先进入 Reconciler</li><li><code>Reconciler（协调器）</code>: 负责找出变化的组件</li><li><code>Renderer（渲染器）</code>: 负责将变化的组件渲染到页面上</li></ul><h3 id="scheduler" tabindex="-1">Scheduler <a class="header-anchor" href="#scheduler" aria-label="Permalink to &quot;Scheduler&quot;">​</a></h3><p>想要知道什么时候浏览器有空闲时间，其实也有部分浏览器实现了相关的 API, 那就是<code>requestIdleCallback</code>, 但是它有几个缺点</p><ul><li>浏览器兼容性</li><li>触发频率不稳定，受很多因素影响。比如当我们的浏览器切换 tab 后，之前 tab 注册的<code>requestIdleCallback</code>触发的频率会变得很低</li></ul><p>基于以上原因，React 实现了功能更完备的<code>requestIdleCallback polyfill</code>，这就是<code>Scheduler</code></p>',12),o=[l];function r(i,n,s,_,h,u){return a(),c("div",null,o)}const f=e(d,[["render",r]]);export{R as __pageData,f as default};
