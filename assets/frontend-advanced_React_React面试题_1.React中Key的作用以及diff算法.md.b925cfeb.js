import{_ as e,o as a,c as i,Q as t}from"./chunks/framework.968e3df4.js";const u=JSON.parse('{"title":"1.React中Key的作用以及diff算法","description":"","frontmatter":{"order":1},"headers":[],"relativePath":"frontend-advanced/React/React面试题/1.React中Key的作用以及diff算法.md","filePath":"frontend-advanced/React/React面试题/1.React中Key的作用以及diff算法.md","lastUpdated":1693988378000}'),f={name:"frontend-advanced/React/React面试题/1.React中Key的作用以及diff算法.md"},d=t('<h1 id="_1-react中key的作用以及diff算法" tabindex="-1">1.React中Key的作用以及diff算法 <a class="header-anchor" href="#_1-react中key的作用以及diff算法" aria-label="Permalink to &quot;1.React中Key的作用以及diff算法&quot;">​</a></h1><h2 id="diff算法的限制" tabindex="-1">Diff算法的限制 <a class="header-anchor" href="#diff算法的限制" aria-label="Permalink to &quot;Diff算法的限制&quot;">​</a></h2><p>为了降低算法复杂度，React的diff会预设三个限制：</p><ol><li><p>只对同级元素进行Diff。如果一个DOM节点在前后两次更新中跨越了层级，那么React不会尝试复用他。</p></li><li><p>两个不同类型的元素会产生出不同的树。如果元素由div变为p，React会销毁div及其子孙节点，并新建p及其子孙节点。</p></li><li><p>开发者可以通过 key prop来暗示哪些子元素在不同的渲染下能保持稳定。考虑如下例子：</p></li></ol><h2 id="单节点的diff" tabindex="-1">单节点的diff <a class="header-anchor" href="#单节点的diff" aria-label="Permalink to &quot;单节点的diff&quot;">​</a></h2><ol><li><p>判断key是否相同</p></li><li><p>相同：判断type是否相同，如果都相同可以直接复用DOM节点，否则删除</p></li><li><p>不相同：删除</p></li></ol><h2 id="多节点diff" tabindex="-1">多节点diff <a class="header-anchor" href="#多节点diff" aria-label="Permalink to &quot;多节点diff&quot;">​</a></h2><p>Diff算法的整体逻辑会经历两轮遍历：</p><ul><li><p>第一轮遍历：处理更新的节点。</p></li><li><p>第二轮遍历：处理剩下的不属于更新的节点</p></li></ul><h3 id="第一轮遍历" tabindex="-1">第一轮遍历 <a class="header-anchor" href="#第一轮遍历" aria-label="Permalink to &quot;第一轮遍历&quot;">​</a></h3><ol><li>遍历 newChildren，看key是否相同，不同就不能复用直接跳出循环。否则如果type不同就标记删除</li></ol>',11),l=[d];function o(r,c,n,_,p,h){return a(),i("div",null,l)}const R=e(f,[["render",o]]);export{u as __pageData,R as default};
