import{_ as t,o as e,c as a,Q as o}from"./chunks/framework.3d945e71.js";const p=JSON.parse('{"title":"HTTP 不同版本的演变","description":"","frontmatter":{},"headers":[],"relativePath":"basic/计算机网络/HTTP/HTTP不同版本的演变.md","filePath":"basic/计算机网络/HTTP/HTTP不同版本的演变.md","lastUpdated":1697531581000}'),T={name:"basic/计算机网络/HTTP/HTTP不同版本的演变.md"},c=o('<h1 id="http-不同版本的演变" tabindex="-1">HTTP 不同版本的演变 <a class="header-anchor" href="#http-不同版本的演变" aria-label="Permalink to &quot;HTTP 不同版本的演变&quot;">​</a></h1><h2 id="http-1-1-相比-http-1-0-有哪些提升" tabindex="-1">HTTP 1.1 相比 HTTP 1.0 有哪些提升 <a class="header-anchor" href="#http-1-1-相比-http-1-0-有哪些提升" aria-label="Permalink to &quot;HTTP 1.1 相比 HTTP 1.0 有哪些提升&quot;">​</a></h2><ol><li>使用 <code>TCP长连接</code> 改善了 HTTP 1.0<code>短连接</code>性能开销</li><li>支持管道网络传输，只要一个请求发出去了，不必等待返回结果，就可以发第二个请求。</li></ol><h2 id="http2-做了哪些优化" tabindex="-1">HTTP2 做了哪些优化 <a class="header-anchor" href="#http2-做了哪些优化" aria-label="Permalink to &quot;HTTP2 做了哪些优化&quot;">​</a></h2><ol><li>基于 HTTPS, 安全性更有保障</li><li><code>头部压缩：</code>如果多个请求有相似的头部，会去除重复部分</li><li><code>二进制传输：</code>头部和数据都是通过二进制传输，并称为<code>帧</code>, 增加了传输效率</li><li><code>多路复用：</code>一个连接并发多个请求或响应，不用按照顺序</li><li><code>服务器推送：</code>服务器可以主动向客户端发送消息，在浏览器请求 html 时，会提前把可能用到的 JS, CSS 文件主动发送给客户端。</li></ol><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>HTTP/2 主要的问题在于，多个 HTTP 请求在复⽤⼀个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求 的。所以⼀旦发⽣了丢包现象，就会触发 TCP 的᯿传机制，这样在⼀个 TCP 连接中的所有的 HTTP 请求都必须等 待这个丢了的包被重传回来。</p></div>',6),i=[c];function l(d,s,P,r,_,h){return e(),a("div",null,i)}const H=t(T,[["render",l]]);export{p as __pageData,H as default};
