import{_ as e,o,c,Q as d}from"./chunks/framework.3d945e71.js";const P=JSON.parse('{"title":"TCP三次握手四次挥手","description":"","frontmatter":{},"headers":[],"relativePath":"basic/计算机网络/TCP/TCP三次握手四次挥手.md","filePath":"basic/计算机网络/TCP/TCP三次握手四次挥手.md","lastUpdated":1694500283000}'),a={name:"basic/计算机网络/TCP/TCP三次握手四次挥手.md"},l=d('<h1 id="tcp三次握手四次挥手" tabindex="-1">TCP三次握手四次挥手 <a class="header-anchor" href="#tcp三次握手四次挥手" aria-label="Permalink to &quot;TCP三次握手四次挥手&quot;">​</a></h1><h2 id="三次握手" tabindex="-1">三次握手 <a class="header-anchor" href="#三次握手" aria-label="Permalink to &quot;三次握手&quot;">​</a></h2><ul><li>第一步：客户端发送<code>SYN</code>报文到服务端发起握手</li><li>第二步：服务端收到<code>SYN</code>报文之后回复<code>SYN</code>和<code>ACK</code>报文给客户端</li><li>第三步：客户端收到<code>SYN</code>和<code>ACK</code>，向服务端发送一个<code>ACK</code>报文</li></ul><h3 id="tcp-快速打开-tfo" tabindex="-1">TCP 快速打开（TFO） <a class="header-anchor" href="#tcp-快速打开-tfo" aria-label="Permalink to &quot;TCP 快速打开（TFO）&quot;">​</a></h3><p><code>TFO</code> 就是为了减少三次握手带来的延时，</p><ul><li>在 <code>TFO</code> 的流程中，首轮三次握手服务端会计算得到一个 <code>TFO cookie</code>，放到 <code>TCP</code> 报文的 <code>Fast Open</code>里面</li><li>客户端拿到这个 <code>cookie</code> 后缓存下来，并完成正常的三次握手；</li><li>下一次的三次握手，客户端就会将之前的 <code>cookie</code> 和 <code>HTTP请求</code>、<code>SYN</code> 发给服务端</li><li>服务端验证 <code>cookie</code> 是否合法，如果合法就正常返回 <code>SYN+ACK</code>；并且返回<code>HTTP响应</code>；</li><li>最后完成三次握手的剩余流程；</li></ul><h3 id="三次握手的意义" tabindex="-1">三次握手的意义 <a class="header-anchor" href="#三次握手的意义" aria-label="Permalink to &quot;三次握手的意义&quot;">​</a></h3><p>客户端和服务端都需要直到各自可收发，因此需要三次握手</p><ul><li>第一次握手成功让服务端知道了客户端具有发送能力</li><li>第二次握手成功让客户端知道了服务端具有接收和发送能力，但此时服务端并不知道客户端是否接收到了自己发送的消息（如果服务端这时立刻给客户端发送数据，这个时候客户端可能还没有准备好接收数据）</li><li>第三次握手让服务端知道了客户端做好了接收自己发送的消息的准备</li></ul><h3 id="为什么-tcp-建立连接需要三次握手-而不是两次" tabindex="-1">为什么 TCP 建立连接需要三次握手，而不是两次 <a class="header-anchor" href="#为什么-tcp-建立连接需要三次握手-而不是两次" aria-label="Permalink to &quot;为什么 TCP 建立连接需要三次握手，而不是两次&quot;">​</a></h3><ul><li>因为这是为了防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误。</li></ul><h3 id="三次握手过程中可以携带数据吗" tabindex="-1">三次握手过程中可以携带数据吗 <a class="header-anchor" href="#三次握手过程中可以携带数据吗" aria-label="Permalink to &quot;三次握手过程中可以携带数据吗&quot;">​</a></h3><ul><li><code>第一次</code>、<code>第二次</code>握手不可以携带数据，因为<code>一握二握</code>时还没有建立连接，会让服务器容易受到攻击（只需要在第一次握手的报文里放大量数据，服务器就会消耗更大的时间和内存空间去处理数据）</li><li>而第三次握手，此时客户端已经处于 <code>(已建立连接状态)</code> ，对于客户端来说，已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也是没问题的。</li></ul><h2 id="四次挥手" tabindex="-1">四次挥手 <a class="header-anchor" href="#四次挥手" aria-label="Permalink to &quot;四次挥手&quot;">​</a></h2><h3 id="为什么要四次挥手-四次挥手流程" tabindex="-1">为什么要四次挥手 &amp; 四次挥手流程 <a class="header-anchor" href="#为什么要四次挥手-四次挥手流程" aria-label="Permalink to &quot;为什么要四次挥手 &amp; 四次挥手流程&quot;">​</a></h3><p>因为<code>TCP</code>是全双工通信，不能单方面完全断开连接</p><ul><li>第一次挥手，客户端发送<code>FIN</code>给服务端</li><li>第二次挥手，服务端回复<code>ACK</code>给客户端，服务端还可以继续向客户端发送数据（若数据没有发送完）</li><li>第三次挥手，服务端发送<code>FIN</code>给客户端</li><li>第四次挥手，客户端回复<code>ACK</code>给服务端，客户端经过 <code>2MSL</code> 的时间后断开，服务端接收到了客户端发出的<code>ACK</code>后立刻断开了到客户端的连接</li></ul><p>至此<code>TCP</code>连接才完全断开。</p><h3 id="四次挥手结束等待-2msl-的意义" tabindex="-1">四次挥手结束等待 2MSL 的意义 <a class="header-anchor" href="#四次挥手结束等待-2msl-的意义" aria-label="Permalink to &quot;四次挥手结束等待 2MSL 的意义&quot;">​</a></h3><ul><li>虽然按道理，四个报文都发送完毕，就可以立即断开，但是我们必须假设网络是不可靠的，有可以最后一个<code>ACK</code>丢失。</li><li>如果最后一个 <code>ACK</code> 丢失了，那么服务端没有收到 <code>ACK</code> 就会发起重传；再次发送 <code>FIN</code> 给客户端；</li><li>客户端收到重传的 <code>FIN</code> 后，会重发 <code>ACK</code> 并重新等待 <code>2MSL</code> 的时间来确保服务端收到了自己的 <code>ACK</code>；</li></ul><p>总结：</p><ul><li>1 个 <code>MSL</code> 确保<code>第四次挥手</code>中<code>主动关闭方</code>最后的 <code>ACK</code> 报文最终能达到对端</li><li>1 个 <code>MSL</code> 确保对端没有收到 <code>ACK</code> 重传的 <code>FIN</code> 报文可以到达</li></ul>',22),i=[l];function t(r,h,n,s,u,_){return o(),c("div",null,i)}const T=e(a,[["render",t]]);export{P as __pageData,T as default};
