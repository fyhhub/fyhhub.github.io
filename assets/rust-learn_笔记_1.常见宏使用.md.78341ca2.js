import{_ as e,o as t,c as a,Q as r}from"./chunks/framework.3d945e71.js";const m=JSON.parse('{"title":"常见宏使用","description":"","frontmatter":{},"headers":[],"relativePath":"rust-learn/笔记/1.常见宏使用.md","filePath":"rust-learn/笔记/1.常见宏使用.md","lastUpdated":1729873804000}'),s={name:"rust-learn/笔记/1.常见宏使用.md"},_=r('<h1 id="常见宏使用" tabindex="-1">常见宏使用 <a class="header-anchor" href="#常见宏使用" aria-label="Permalink to &quot;常见宏使用&quot;">​</a></h1><h2 id="repr" tabindex="-1">#[repr] <a class="header-anchor" href="#repr" aria-label="Permalink to &quot;#\\[repr]&quot;">​</a></h2><p><img src="https://fastly.jsdelivr.net/gh/fyhhub/imgs@main/17128837221061712883721238.png" alt="17128837221061712883721238.png"></p><p>虽然，Rust 编译器默认为开发者优化结构体的排列，但你也可以使用<code>#[repr]</code>宏，强制让 Rust 编译器不做优化，和 C 的行为一致，这样，Rust 代码可以方便地和 C 代码无缝交互。</p>',4),o=[_];function n(c,i,d,l,p,h){return t(),a("div",null,o)}const f=e(s,[["render",n]]);export{m as __pageData,f as default};
